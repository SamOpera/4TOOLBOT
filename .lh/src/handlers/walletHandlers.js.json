{
    "sourceFile": "src/handlers/walletHandlers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1760641845521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1760641845521,
            "name": "Commit-0",
            "content": "const crypto = require('crypto');\nconst bs58Module = require('bs58');\nconst bs58 = bs58Module.default || bs58Module;\nconst TelegramErrorHandler = require('../utils/telegramErrorHandler');\n\nclass WalletHandlers {\n    constructor(bot, db, config) {\n        this.bot = bot;\n        this.db = db;\n        this.config = config;\n        this.lastMessageIds = new Map();\n        this.lastWalletMessageId = null;\n    }\n\n    // Handle input messages for wallet-related waiting states\n    async handleMessage(ctx, userState) {\n        const chatId = ctx.chat.id;\n        const telegramId = ctx.from.id.toString();\n        const message = ctx.message.text;\n\n        try {\n            // Get user state from bot if not provided\n            if (!userState) {\n                userState = this.bot.userStates.get(telegramId);\n            }\n            \n            if (userState && userState.state) {\n                switch (userState.state) {\n                    case 'waiting_external_wallet': {\n                        const walletAddress = message.trim();\n                        if (!this.validateWalletAddress(walletAddress)) {\n                            await this.sendAndStoreMessage(chatId, 'Invalid wallet address. Please enter a valid Solana address.');\n                            return true;\n                        }\n                        await this.handleExternalWalletInput(chatId, telegramId, walletAddress);\n                        return { handled: true, clearState: true };\n                    }\n                    case 'awaiting_private_key': {\n                        if (message && message.trim().length > 0) {\n                            await this.handlePrivateKeyImport(chatId, telegramId, message);\n                        } else {\n                            await this.sendAndStoreMessage(chatId, 'Please send a valid private key.');\n                        }\n                        return { handled: true, clearState: true };\n                    }\n                    default:\n                        return false; // Not handled by wallet handlers\n                }\n            }\n            return false;\n        } catch (error) {\n            console.error('Error in walletHandlers.handleMessage:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while processing your wallet input.');\n            return true;\n        }\n    }\n\n    async handleExternalWalletInput(chatId, telegramId, walletAddress) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            \n            try {\n                // Skip validation and directly add the wallet address\n                await this.db.addExternalWallet(user.id, walletAddress);\n                \n                const message = `\n*‚úÖ External Wallet Added*\n\nWallet address: \\`${walletAddress}\\`\n\nThe wallet has been added to your monitored list. You can now enable copy trading for this wallet.`;\n\n                const keyboard = {\n                    inline_keyboard: [\n                        [\n                            { text: 'üîÑ Back to Copy Trade', callback_data: 'strategy_copy_trade' }\n                        ]\n                    ]\n                };\n\n                await this.sendAndStoreMessage(chatId, message, {\n                    parse_mode: 'Markdown',\n                    reply_markup: keyboard\n                });\n\n            } catch (error) {\n                if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n                    await this.sendAndStoreMessage(chatId, 'This wallet address is already being monitored.');\n                } else {\n                    throw error;\n                }\n            }\n\n        } catch (error) {\n            console.error('Error handling external wallet input:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, there was an error adding the external wallet.');\n        }\n    }\n\n    async handleCreateWallet(chatId, telegramId) {\n    try {\n        const wallet = await this.generateWallet();\n        const encryptedKey = this.encryptPrivateKey(JSON.stringify(wallet.privateKey), telegramId);\n        \n        const user = await this.db.getUserByTelegramId(telegramId);\n        await this.db.createWallet(user.id, wallet.publicKey, encryptedKey, {\n            is_locked: false,\n            is_active: true\n        });\n\n        // Create the base58 version for wallet import\n        const privateKeyBase58 = bs58.encode(Uint8Array.from(wallet.privateKey));\n\n        const message = `\n*üéâ New Wallet Created!*\n\n*Public Key:*\n\n\\`${wallet.publicKey}\\`\n\n*Private Key (Base58, for Phantom/Sollet/Backpack):*\n\n\\`${privateKeyBase58}\\`\n\n‚ö†Ô∏è *IMPORTANT:* \n- Use the Base58 key above to import into wallets like Phantom, Sollet, Backpack, etc.\n- Save your private key securely\n- Never share it with anyone\n- It cannot be recovered if lost\n- Keep it in a safe place`;\n\n        const keyboard = {\n            inline_keyboard: [\n                [\n                    { text: '‚úÖ I\\'ve Saved My Keys', callback_data: 'keys_saved' }\n                ]\n            ]\n        };\n\n        const sentMessage = await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n\n        this.lastWalletMessageId = sentMessage.message_id;\n    } catch (error) {\n        console.error('Error creating wallet:', error);\n        await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while creating your wallet.');\n    }\n}\n\n    async handleImportWallet(chatId, telegramId) {\n        try {\n            this.bot.userStates.set(telegramId, {\n                state: 'awaiting_private_key',\n                data: {}\n            });\n\n            const message = `\n*üìù Import Existing Wallet*\n\nPlease send your private key in one of these formats:\n\nüîë *Supported Formats:*\n‚Ä¢ **Base58** (87-88 characters) - Most common for Solana\n‚Ä¢ **Base64** (88 characters) - Standard encoding\n‚Ä¢ **Hex** (128 characters) - With or without 0x prefix\n‚Ä¢ **Array** ([n1,n2,n3...]) - 64 comma-separated numbers\n\nüìã *Example formats:*\n‚Ä¢ Base58: \\`4NwwCJ...\\`\n‚Ä¢ Base64: \\`dGVzdC1wcml2YXRlLWtleQ==\\`\n‚Ä¢ Hex: \\`0123456789abcdef...\\` (128 chars)\n‚Ä¢ Hex with 0x: \\`0x0123456789abcdef...\\`\n‚Ä¢ Array: \\`[123,45,67,89,...]\\`\n\n‚ö†Ô∏è *Security Tips:*\n‚Ä¢ Send the private key in a new message\n‚Ä¢ Delete the message after importing\n‚Ä¢ Never share your private key with anyone\n‚Ä¢ Make sure you're in a private chat\n\n*To cancel:* Send /cancel`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: '‚ùå Cancel', callback_data: 'wallet_management' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error in import wallet setup:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while setting up wallet import.');\n        }\n    }\n\n    async handlePrivateKeyImport(chatId, telegramId, privateKeyInput) {\n        try {\n            if (!this.bot.userStates.get(telegramId) || this.bot.userStates.get(telegramId).state !== 'awaiting_private_key') {\n                await this.sendAndStoreMessage(chatId, 'Please use the import wallet option from the wallet management menu.');\n                return;\n            }\n\n            console.log('Importing private key...');\n            const cleanInput = privateKeyInput.trim();\n            console.log('Private key length:', cleanInput.length);\n            console.log('Private key preview:', cleanInput.substring(0, 10) + '...');\n            \n            let privateKeyBuffer;\n            let originalFormat = '';\n            \n            // 1. Try base58 format (most common for Solana private keys)\n            if (!originalFormat && cleanInput.length >= 87 && cleanInput.length <= 88) {\n                try {\n                    console.log('Attempting base58 decode...');\n                    if (/^[1-9A-HJ-NP-Za-km-z]+$/.test(cleanInput)) {\n                        privateKeyBuffer = bs58.decode(cleanInput);\n                        console.log('Base58 decode successful, buffer length:', privateKeyBuffer.length);\n                        if (privateKeyBuffer.length === 64) {\n                            originalFormat = 'base58';\n                            console.log('‚úÖ Detected base58 format');\n                        } else {\n                            console.log('‚ùå Base58 decode successful but wrong length:', privateKeyBuffer.length);\n                            privateKeyBuffer = null;\n                        }\n                    } else {\n                        console.log('‚ùå String contains invalid base58 characters');\n                    }\n                } catch (e) {\n                    console.log('‚ùå Base58 decode failed:', e.message);\n                }\n            }\n            \n            // 2. Try base64 format\n            if (!originalFormat && cleanInput.length === 88) {\n                try {\n                    console.log('Attempting base64 decode...');\n                    const testBuffer = Buffer.from(cleanInput, 'base64');\n                    console.log('Base64 decode successful, buffer length:', testBuffer.length);\n                    if (testBuffer.length === 64) {\n                        privateKeyBuffer = testBuffer;\n                        originalFormat = 'base64';\n                        console.log('‚úÖ Detected base64 format');\n                    } else {\n                        console.log('‚ùå Base64 decode successful but wrong length:', testBuffer.length);\n                    }\n                } catch (e) {\n                    console.log('‚ùå Base64 decode failed:', e.message);\n                }\n            }\n            \n            // 3. Try hex format (128 characters for 64-byte private key)\n            if (!originalFormat && /^[0-9a-fA-F]{128}$/.test(cleanInput)) {\n                try {\n                    console.log('Attempting hex decode...');\n                    privateKeyBuffer = Buffer.from(cleanInput, 'hex');\n                    originalFormat = 'hex';\n                    console.log('‚úÖ Detected hex format');\n                } catch (e) {\n                    console.log('‚ùå Hex decode failed:', e.message);\n                }\n            }\n            \n            // 4. Try hex format with 0x prefix\n            if (!originalFormat && /^0x[0-9a-fA-F]{128}$/.test(cleanInput)) {\n                try {\n                    console.log('Attempting hex decode with 0x prefix...');\n                    privateKeyBuffer = Buffer.from(cleanInput.slice(2), 'hex');\n                    originalFormat = 'hex';\n                    console.log('‚úÖ Detected hex format with 0x prefix');\n                } catch (e) {\n                    console.log('‚ùå Hex decode with 0x prefix failed:', e.message);\n                }\n            }\n            \n            // 5. Try array format (comma separated numbers)\n            if (!originalFormat && cleanInput.startsWith('[') && cleanInput.endsWith(']')) {\n                try {\n                    console.log('Attempting array format decode...');\n                    const arrayString = cleanInput.slice(1, -1);\n                    const numbers = arrayString.split(',').map(s => parseInt(s.trim()));\n                    if (numbers.length === 64 && numbers.every(n => n >= 0 && n <= 255)) {\n                        privateKeyBuffer = Buffer.from(numbers);\n                        originalFormat = 'array';\n                        console.log('‚úÖ Detected array format');\n                    } else {\n                        console.log('‚ùå Array format invalid - length:', numbers.length);\n                    }\n                } catch (e) {\n                    console.log('‚ùå Array format decode failed:', e.message);\n                }\n            }\n            \n            if (!originalFormat || !privateKeyBuffer) {\n                console.log('‚ùå No valid format detected');\n                throw new Error('Invalid private key format. Supported formats:\\n‚Ä¢ Base58 (87-88 characters)\\n‚Ä¢ Base64 (88 characters)\\n‚Ä¢ Hex (128 characters, with or without 0x prefix)\\n‚Ä¢ Array format [n1,n2,...]');\n            }\n            \n            console.log('‚úÖ Format detection successful:', originalFormat);\n            console.log('Decoded private key buffer length:', privateKeyBuffer.length);\n            \n            if (privateKeyBuffer.length !== 64) {\n                throw new Error(`Invalid private key length: ${privateKeyBuffer.length}, expected 64 bytes`);\n            }\n            \n            const { Keypair } = require('@solana/web3.js');\n            let keypair;\n            try {\n                keypair = Keypair.fromSecretKey(privateKeyBuffer);\n            } catch (error) {\n                throw new Error('Invalid private key: Could not create keypair');\n            }\n            \n            const publicKey = keypair.publicKey.toString();\n            \n            console.log('‚úÖ Successfully imported Solana wallet!');\n            console.log('Public Key:', publicKey);\n            console.log('Original format:', originalFormat);\n            \n            const encryptedKey = this.encryptPrivateKey(JSON.stringify(Array.from(privateKeyBuffer)), telegramId);\n            const user = await this.db.getUserByTelegramId(telegramId);\n\n            if (!user) {\n                throw new Error('User not found. Please try again.');\n            }\n            \n            try {\n                await this.db.createWallet(user.id, publicKey, encryptedKey, {\n                    is_locked: false,\n                    is_active: true\n                });\n            } catch (error) {\n                if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n                    const message = `\n*‚ö†Ô∏è Wallet Already Exists*\n\nA wallet with this public key is already imported:\n\\`${publicKey}\\`\n\nWould you like to switch to this wallet?`;\n\n                    const keyboard = {\n                        inline_keyboard: [\n                            [\n                                { text: '‚úÖ Switch to Wallet', callback_data: `switch_to_${publicKey}` },\n                                { text: '‚ùå Cancel', callback_data: 'wallet_management' }\n                            ]\n                        ]\n                    };\n\n                    await this.sendAndStoreMessage(chatId, message, {\n                        parse_mode: 'Markdown',\n                        reply_markup: keyboard\n                    });\n                    return;\n                }\n                throw error;\n            }\n\n            this.bot.userStates.delete(telegramId);\n\n            const message = `\n*‚úÖ Wallet Imported Successfully!*\n\n*Public Key:*\n\\`${publicKey}\\`\n\n*Format Detected:* ${originalFormat.toUpperCase()}\n\nYour wallet has been imported and is ready to use.`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: 'üìä View Portfolio', callback_data: 'view_portfolio' },\n                        { text: '‚ö°Ô∏è Trade', callback_data: 'trade' }\n                    ],\n                    [\n                        { text: 'üè† Go to Main Menu', callback_data: 'main_menu' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n\n            try {\n                await this.bot.deleteMessage(chatId, this.lastMessageIds.get(chatId));\n            } catch (error) {\n                console.error('Error deleting private key message:', error);\n            }\n        } catch (error) {\n            console.error('Error importing wallet:', error);\n            let errorMessage = 'Sorry, there was an error importing your wallet.';\n            if (error.message.includes('Invalid private key format')) {\n                errorMessage = `‚ùå Invalid private key format.\\n\\nPlease ensure your private key is in one of these formats:\\n‚Ä¢ Base58 (87-88 characters)\\n‚Ä¢ Base64 (88 characters)\\n‚Ä¢ Hex (128 characters, with or without 0x prefix)\\n‚Ä¢ Array format [n1,n2,n3...]`;\n            } else if (error.message.includes('Invalid private key length')) {\n                errorMessage = '‚ùå Invalid private key length. Please check your private key and try again.';\n            } else if (error.message.includes('Invalid private key')) {\n                errorMessage = '‚ùå Invalid private key. Please check your private key and try again.';\n            } else if (error.message.includes('User not found')) {\n                errorMessage = '‚ùå User not found. Please try again or contact support.';\n            } else {\n                errorMessage = `‚ùå Error: ${error.message}`;\n            }\n            \n            await this.sendAndStoreMessage(chatId, errorMessage);\n            this.bot.userStates.delete(telegramId);\n        }\n    }\n\n    async handleExportKeys(chatId, telegramId) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            const wallets = await this.db.getWalletsByUserId(user.id);\n\n            if (wallets.length === 0) {\n                await this.sendAndStoreMessage(chatId, 'No wallets found to export.');\n                return;\n            }\n\n            const message = `\n*üîë Export Wallet Keys*\n\nSelect a wallet to export its private key:\n\n‚ö†Ô∏è *Security Warning:*\n- Only export in a secure environment\n- Never share your private keys\n- Delete exported messages after saving`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    ...wallets.map(wallet => [\n                        { \n                            text: `üì± ${wallet.public_key.slice(0, 8)}...${wallet.public_key.slice(-8)}${wallet.is_active ? ' (Active)' : ''}`, \n                            callback_data: `export_wallet_${wallet.id}` \n                        }\n                    ]),\n                    [\n                        { text: '‚óÄÔ∏è Back', callback_data: 'wallet_management' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error in handleExportKeys:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading wallets.');\n        }\n    }\n\n    async handleWalletExport(chatId, telegramId, walletId) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            const wallet = await this.db.getWalletById(walletId, user.id);\n\n            if (!wallet) {\n                await this.sendAndStoreMessage(chatId, 'Wallet not found.');\n                return;\n            }\n\n            const message = `\n*‚ö†Ô∏è Export Private Key Warning*\n\nYou are about to export the private key for:\n\\`${wallet.public_key}\\`\n\n*SECURITY RISKS:*\n- Anyone with this key can access your funds\n- Never share or store it insecurely\n- This action cannot be undone\n\nAre you sure you want to proceed?`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: '‚úÖ Yes, Export Key', callback_data: `confirm_export_${walletId}` },\n                        { text: '‚ùå Cancel', callback_data: 'export_keys' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error in handleWalletExport:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while preparing the export.');\n        }\n    }\n\n    async handleConfirmExport(chatId, telegramId, walletId) {\n    try {\n        const user = await this.db.getUserByTelegramId(telegramId);\n        const wallet = await this.db.getWalletById(walletId, user.id);\n\n        if (!wallet) {\n            await this.sendAndStoreMessage(chatId, 'Wallet not found.');\n            return;\n        }\n\n        // Decrypt the private key\n        const privateKeyStr = this.decryptPrivateKey(wallet.encrypted_private_key, telegramId);\n        let privateKeyArray;\n\n        try {\n            privateKeyArray = JSON.parse(privateKeyStr);\n        } catch (e) {\n            const Buffer = require('buffer').Buffer;\n            let buf = null;\n            if (/^[A-Za-z0-9+/=]+$/.test(privateKeyStr) && privateKeyStr.length === 88) {\n                buf = Buffer.from(privateKeyStr, 'base64');\n            } else if (/^\\d+(,\\d+)*$/.test(privateKeyStr)) {\n                buf = Buffer.from(privateKeyStr.split(',').map(n => parseInt(n.trim())));\n            } else {\n                throw new Error(\"Unknown private key format! Contact support.\");\n            }\n            privateKeyArray = Array.from(buf);\n        }\n\n        if (!privateKeyArray || privateKeyArray.length !== 64) {\n            throw new Error(\"Private key is not 64 bytes long. Cannot export.\");\n        }\n\n        const privateKeyBase58 = bs58.encode(Uint8Array.from(privateKeyArray));\n\n        const message = `\n*üîë Private Key Export*\n\n*Wallet:* \\`${wallet.public_key}\\`\n\n*Private Key (Base58, for Phantom/Sollet/Backpack):*\n\\`${privateKeyBase58}\\`\n\n*Advanced (Uint8Array/JSON, for developers):*\n\\`${JSON.stringify(privateKeyArray)}\\`\n\n‚ö†Ô∏è *IMPORTANT:*\n- Save this key securely immediately\n- Delete this message after saving\n- Never share this key with anyone\n- You are responsible for its security\n`;\n\n        const keyboard = {\n            inline_keyboard: [\n                [\n                    { text: 'üóëÔ∏è Delete This Message', callback_data: 'delete_export_message' }\n                ],\n                [\n                    { text: '‚úÖ I\\'ve Saved It', callback_data: 'export_keys' }\n                ]\n            ]\n        };\n\n        const sentMessage = await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n\n        // Optionally, auto-delete the message after 5 minutes\n        setTimeout(async () => {\n            try {\n                await this.bot.deleteMessage(chatId, sentMessage.message_id);\n            } catch (error) {\n                console.error('Error auto-deleting export message:', error);\n            }\n        }, 5 * 60 * 1000);\n\n    } catch (error) {\n        console.error('Error in handleConfirmExport:', error);\n        await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while exporting the key.');\n    }\n}\n\n    async handleWalletSwitch(chatId, telegramId, walletId) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            await this.db.deactivateAllWallets(user.id);\n            await this.db.activateWallet(walletId, user.id);\n            const wallet = await this.db.getWalletById(walletId, user.id);\n\n            const message = `\n*‚úÖ Wallet Switched Successfully*\n\n*Active Wallet:*\n\\`${wallet.public_key}\\`\n\nYou can now trade with this wallet.`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: 'üìä View Portfolio', callback_data: 'view_portfolio' },\n                        { text: '‚ö°Ô∏è Trade', callback_data: 'trade' }\n                    ],\n                    [\n                        { text: 'üè† Main Menu', callback_data: 'main_menu' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error in handleWalletSwitch:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while switching wallets.');\n        }\n    }\n\n    async handleSwitchToWallet(chatId, telegramId, publicKey) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            if (!user) {\n                await this.sendAndStoreMessage(chatId, 'User not found.');\n                return;\n            }\n\n            const wallets = await this.db.getWalletsByUserId(user.id);\n            const targetWallet = wallets.find(w => w.public_key === publicKey);\n            \n            if (!targetWallet) {\n                await this.sendAndStoreMessage(chatId, 'Wallet not found.');\n                return;\n            }\n\n            await this.db.setActiveWallet(user.id, targetWallet.id);\n\n            const message = `\n*‚úÖ Wallet Activated Successfully!*\n\n*Active Wallet:*\n\\`${targetWallet.public_key}\\`\n\nYou can now use this wallet for trading.`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: 'üìä View Portfolio', callback_data: 'view_portfolio' },\n                        { text: '‚ö°Ô∏è Trade', callback_data: 'trade' }\n                    ],\n                    [\n                        { text: 'üè† Go to Main Menu', callback_data: 'main_menu' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error switching to wallet:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, there was an error activating the wallet.');\n        }\n    }\n\n   async handleWalletActions(ctx) {\n        // --- CRITICAL FIX: Ensure callbackData is declared and assigned first ---\n        const callbackData = ctx.callbackQuery.data; \n        const chatId = ctx.chat.id;\n        const telegramId = ctx.from.id.toString();\n        \n        console.log('[DEBUG] Entered handleWalletActions with callbackData:', callbackData);\n        \n        // This is the action derived from the callback (e.g., 'create', 'import', 'switch')\n        const action = callbackData.split('_')[0]; \n        \n        try {\n            // --- Direct actions ---\n            if (callbackData === 'create_wallet') {\n                await this.handleCreateWallet(chatId, telegramId);\n                return true;\n            } \n            \n            if (callbackData === 'import_wallet') {\n                await this.handleImportWallet(chatId, telegramId);\n                return true;\n            } \n            \n            if (callbackData === 'export_keys') {\n                await this.handleExportKeys(chatId, telegramId);\n                return true;\n            } \n            \n            if (callbackData === 'switch_wallet') {\n                await this.handleSwitchWalletMenu(chatId, telegramId);\n                return true;\n            }\n\n            // --- Logic for selecting a specific wallet to switch to or export ---\n            \n            if (callbackData.startsWith('export_wallet_')) {\n                const walletId = callbackData.replace('export_wallet_', '');\n                await this.handleWalletExport(chatId, telegramId, walletId);\n                return true;\n            }\n\n            if (callbackData.startsWith('confirm_export_')) {\n                const walletId = callbackData.replace('confirm_export_', '');\n                await this.handleConfirmExport(chatId, telegramId, walletId);\n                return true;\n            }\n            \n            if (callbackData.startsWith('switch_wallet_') || callbackData.startsWith('switch_to_')) {\n                const identifier = callbackData.replace('switch_wallet_', '').replace('switch_to_', '');\n                \n                if (identifier.length > 20) {\n                    await this.handleSwitchToWallet(chatId, telegramId, identifier);\n                } else {\n                    await this.handleWalletSwitch(chatId, telegramId, identifier);\n                }\n                return true;\n            }\n\n            if (callbackData === 'keys_saved') {\n                // Logic to delete old message and show the new menu\n                const message = `\n*‚úÖ Keys Saved Successfully!*\nYour wallet is now ready to use.`;\n                const keyboard = {\n                    inline_keyboard: [\n                        [\n                            { text: 'üìä View Portfolio', callback_data: 'view_portfolio' },\n                            { text: '‚ö°Ô∏è Trade', callback_data: 'trade' }\n                        ],\n                        [\n                            { text: 'üè† Go to Main Menu', callback_data: 'main_menu' }\n                        ]\n                    ]\n                };\n\n                await this.sendAndStoreMessage(chatId, message, {\n                    parse_mode: 'Markdown',\n                    reply_markup: keyboard\n                });\n\n                // Delete the wallet creation message\n                try {\n                    // Assuming lastWalletMessageId is part of 'this' or accessible\n                    if (this.lastWalletMessageId) {\n                        await this.bot.deleteMessage(chatId, this.lastWalletMessageId);\n                        this.lastWalletMessageId = null;\n                    }\n                } catch (error) {\n                    console.error('Error deleting wallet creation message:', error);\n                }\n                return true;\n            }\n\n            // If the action is not handled here, return false for the main router\n            return false;\n            \n        } catch (error) {\n            console.error('Error processing handleWalletActions callback:', error);\n            await this.bot.answerCallbackQuery(ctx.callbackQuery.id, 'Error processing request.');\n            await this.sendAndStoreMessage(chatId, 'A critical error occurred during wallet management.');\n            return true; \n        }\n    }\n\n    validatePrivateKeyFormat(privateKey) {\n        const cleaned = privateKey.trim();\n        if (cleaned.length >= 87 && cleaned.length <= 88) {\n            try {\n                return /^[1-9A-HJ-NP-Za-km-z]+$/.test(cleaned);\n            } catch {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    validateWalletAddress(address) {\n        try {\n            const decoded = bs58.decode(address);\n            return decoded.length === 32;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    async generateWallet() {\n        const { Keypair } = require('@solana/web3.js');\n        const keypair = Keypair.generate();\n        return {\n            publicKey: keypair.publicKey.toString(),\n            privateKey: Array.from(keypair.secretKey)\n        };\n    }\n\n    async handleSwitchWalletMenu(chatId, telegramId) {\n    try {\n        const user = await this.db.getUserByTelegramId(telegramId);\n        if (!user) {\n            await this.sendAndStoreMessage(chatId, 'User not found.');\n            return;\n        }\n        const wallets = await this.db.getWalletsByUserId(user.id);\n\n        if (!wallets || wallets.length === 0) {\n            await this.sendAndStoreMessage(chatId, 'You have no wallets to switch.');\n            return;\n        }\n\n        const message = `\n*üîÑ Switch Wallet*\n\nSelect a wallet to activate:`;\n\n        const keyboard = {\n            inline_keyboard: [\n                ...wallets.map(wallet => [\n                    {\n                        text: `${wallet.public_key.slice(0, 8)}...${wallet.public_key.slice(-8)}${wallet.is_active ? ' (Active)' : ''}`,\n                        callback_data: `switch_wallet_${wallet.id}`\n                    }\n                ]),\n                [\n                    { text: '‚óÄÔ∏è Back', callback_data: 'wallet_management' }\n                ]\n            ]\n        };\n\n        await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n    } catch (error) {\n        console.error('Error in handleSwitchWalletMenu:', error);\n        await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while showing your wallets.');\n    }\n}\n\n    encryptPrivateKey(privateKey, userId) {\n        const algorithm = 'aes-256-cbc';\n        const key = crypto.scryptSync(userId, 'salt', 32);\n        const iv = crypto.randomBytes(16);\n        const cipher = crypto.createCipheriv(algorithm, key, iv);\n        let encrypted = cipher.update(privateKey, 'utf8', 'hex');\n        encrypted += cipher.final('hex');\n        return iv.toString('hex') + ':' + encrypted;\n    }\n\n    decryptPrivateKey(encryptedKey, userId) {\n        const algorithm = 'aes-256-cbc';\n        const key = crypto.scryptSync(userId, 'salt', 32);\n        const parts = encryptedKey.split(':');\n        const iv = Buffer.from(parts[0], 'hex');\n        const encrypted = parts[1];\n        const decipher = crypto.createDecipheriv(algorithm, key, iv);\n        let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n        return decrypted;\n    }\n\n    async sendAndStoreMessage(chatId, message, options = {}) {\n        return await TelegramErrorHandler.sendMessage(this.bot, chatId, message, options, this.lastMessageIds);\n    }\n}\n\nmodule.exports = WalletHandlers;"
        }
    ]
}