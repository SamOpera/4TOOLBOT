{
    "sourceFile": "src/modules/telegramBot.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1760613601428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760614617998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1268,9 +1268,36 @@\n \n             // --- Handle token selection for withdrawal ---\n             if (callbackData.startsWith('withdraw_token_')) {\n                 await this.withdrawHandlers.handleCallbackQuery(ctx);\n+\n+             // Add this new block right after the 'withdraw_token_' logic\n+// (Around Line 1340 in your full code)\n+\n+            // --- Handle Direct Wallet Actions (Create, Import, Export, Switch) ---\n+            if (callbackData === 'create_wallet' || \n+                callbackData === 'import_wallet' || \n+                callbackData === 'export_keys' || \n+                callbackData === 'switch_wallet' ||\n+                callbackData.startsWith('export_wallet_') ||\n+                callbackData.startsWith('confirm_export_')) {\n                 \n+                // Delegate all wallet-related button clicks to the WalletHandlers module\n+                await this.walletHandlers.handleCallbackQuery(ctx);\n+                \n+                // Acknowledge the callback query to dismiss the loading clock\n+                if (this.bot && this.bot.answerCallbackQuery) {\n+                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n+                }\n+                return; // CRITICAL: Stop execution here\n+            }\n+\n+            // --- Handle Custom Actions (Rewards, Withdraw, Token Selection) ---\n+            // The existing 'withdraw' and 'rewards' logic goes here...\n+\n+            // --- DELEGATE TO ROUTER FOR EVERYTHING ELSE (Trading, Strategy, etc.) ---\n+            await this.callbackRouter.handleCallbackQuery(ctx);   \n+                \n                 // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n                 if (this.bot && this.bot.answerCallbackQuery) {\n                     await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n                 }\n"
                },
                {
                    "date": 1760615188561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1250,63 +1250,16 @@\n             if (callbackData === 'rewards') {\n                 await this.handleClaimRewards(chatId, telegramId);\n             }\n \n-           // In TelegramBotManager.js, inside the handleCallbackQuery(ctx) function\n-\n-            // ... (Handling universal navigation: 'main_menu', 'wallet_management')\n-\n-            // --- Handle Withdraw button ---\n             if (callbackData === 'withdraw') {\n                 await this.withdrawHandlers.handleWithdrawStart(chatId, telegramId);\n-                \n-                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n-                if (this.bot && this.bot.answerCallbackQuery) {\n-                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n-                }\n-                return; \n             }\n \n-            // --- Handle token selection for withdrawal ---\n             if (callbackData.startsWith('withdraw_token_')) {\n                 await this.withdrawHandlers.handleCallbackQuery(ctx);\n-\n-             // Add this new block right after the 'withdraw_token_' logic\n-// (Around Line 1340 in your full code)\n-\n-            // --- Handle Direct Wallet Actions (Create, Import, Export, Switch) ---\n-            if (callbackData === 'create_wallet' || \n-                callbackData === 'import_wallet' || \n-                callbackData === 'export_keys' || \n-                callbackData === 'switch_wallet' ||\n-                callbackData.startsWith('export_wallet_') ||\n-                callbackData.startsWith('confirm_export_')) {\n-                \n-                // Delegate all wallet-related button clicks to the WalletHandlers module\n-                await this.walletHandlers.handleCallbackQuery(ctx);\n-                \n-                // Acknowledge the callback query to dismiss the loading clock\n-                if (this.bot && this.bot.answerCallbackQuery) {\n-                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n-                }\n-                return; // CRITICAL: Stop execution here\n             }\n-\n-            // --- Handle Custom Actions (Rewards, Withdraw, Token Selection) ---\n-            // The existing 'withdraw' and 'rewards' logic goes here...\n-\n-            // --- DELEGATE TO ROUTER FOR EVERYTHING ELSE (Trading, Strategy, etc.) ---\n-            await this.callbackRouter.handleCallbackQuery(ctx);   \n-                \n-                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n-                if (this.bot && this.bot.answerCallbackQuery) {\n-                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n-                }\n-                return; \n-            }\n             \n-            // ... (rest of the logic, like 'rewards', 'settings', etc., should also return after acknowledging)\n-            \n             // --- DELEGATE TO ROUTER FOR EVERYTHING ELSE (Trading, Strategy, Security) ---\n             await this.callbackRouter.handleCallbackQuery(ctx);\n             \n             // Acknowledge callback for all actions handled successfully above\n"
                },
                {
                    "date": 1760615289030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1250,16 +1250,36 @@\n             if (callbackData === 'rewards') {\n                 await this.handleClaimRewards(chatId, telegramId);\n             }\n \n+            // In TelegramBotManager.js, inside the handleCallbackQuery(ctx) function\n+\n+            // ... (Handling universal navigation: 'main_menu', 'wallet_management')\n+\n+            // --- Handle Withdraw button ---\n             if (callbackData === 'withdraw') {\n                 await this.withdrawHandlers.handleWithdrawStart(chatId, telegramId);\n+                \n+                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n+                if (this.bot && this.bot.answerCallbackQuery) {\n+                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n+                }\n+                return; \n             }\n \n+            // --- Handle token selection for withdrawal ---\n             if (callbackData.startsWith('withdraw_token_')) {\n                 await this.withdrawHandlers.handleCallbackQuery(ctx);\n+                \n+                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n+                if (this.bot && this.bot.answerCallbackQuery) {\n+                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n+                }\n+                return; \n             }\n             \n+            // ... (rest of the logic, like 'rewards', 'settings', etc., should also return after acknowledging)\n+            \n             // --- DELEGATE TO ROUTER FOR EVERYTHING ELSE (Trading, Strategy, Security) ---\n             await this.callbackRouter.handleCallbackQuery(ctx);\n             \n             // Acknowledge callback for all actions handled successfully above\n"
                }
            ],
            "date": 1760613601428,
            "name": "Commit-0",
            "content": "const TelegramBot = require('node-telegram-bot-api');\nconst DatabaseManager = require('./database');\nconst FeeManagement = require('./feeManagement');\nconst TradingExecution = require('./tradingExecution');\nconst RugCheck = require('./rugCheck');\nconst TokenAnalysis = require('./tokenAnalysis');\nconst BuyManager = require('./buyManager');\nconst SellManager = require('./sellManager');\nconst RulesCommand = require('../commands/rules');\nconst RuleEngine = require('../services/ruleEngine');\nconst FileExportService = require('../services/fileExportService');\nconst AutonomousService = require('../services/autonomousService');\nconst WithdrawHandlers = require('../handlers/withdrawHandlers');\nconst {\n    WalletHandlers,\n    PortfolioHandlers,\n    TradingHandlers,\n    StrategyHandlers,\n    RuleHandlers,\n    ExportHandlers,\n    SecurityHandlers,\n    CopyTradeHandlers,\n    SettingsHandlers\n} = require('../handlers');\nconst CallbackRouter = require('./callbackRouter');\n\n// Utility modules\nconst TelegramUtils = require('../utils/telegramUtils');\nconst MessageManager = require('../utils/messageManager');\nconst MenuManager = require('../utils/menuManager');\nconst RulesManager = require('../utils/rulesManager');\n\nclass TelegramBotManager {\n    constructor(config, manualManagementService) {\n        this.config = config;\n        if (!config.telegram || !config.telegram.token) {\n            throw new Error('Telegram token is required');\n        }\n\n        try {\n            // Webhook-only: bot is provided by the webhook server\n            this.bot = null;\n            this.webhookMode = true;\n\n            // Initialize components that do NOT depend on bot instance\n            this.db = new DatabaseManager();\n            this.feeManager = new FeeManagement(config);\n            this.tradingExecution = new TradingExecution(config);\n            this.rugCheck = new RugCheck();\n            this.tokenAnalysis = new TokenAnalysis();\n            this.ruleEngine = new RuleEngine(this.db, config);\n            this.buyManager = new BuyManager(config, this.tradingExecution, this.db, manualManagementService);\n            this.fileExportService = new FileExportService();\n            this.tempStorage = new Map();\n            this.activeRules = new Map();\n\n            // If we already have a bot (polling mode), finish bot-dependent initialization\n            // In webhook-only mode, initialization with bot occurs in setBot()\n        } catch (error) {\n            console.error('Failed to initialize Telegram bot:', error.message);\n            throw new Error(`Failed to initialize Telegram bot: ${error.message}`);\n        }\n    }\ninitializeWithBot(config) {\n    // Instantiate services and handlers that require a live bot instance\n    this.autonomousService = new AutonomousService(config, this.ruleEngine, this.bot);\n    const MessageDispatcher = require('../utils/messageDispatcher');\n    this.dispatcher = new MessageDispatcher(this.bot, { maxConcurrent: 10, minIntervalMs: 40 });\n    this.messageManager = new MessageManager(this.bot);\n    this.menuManager = new MenuManager(this.bot, this.db, this.messageManager);\n    this.rulesCommand = new RulesCommand(this.bot, this.db, config);\n    this.rulesManager = new RulesManager(this.bot, this.db, this.messageManager, this.rulesCommand);\n    this.sellManager = new SellManager(config, this.tradingExecution, this.db, this.messageManager);\n\n    this.walletHandlers = new WalletHandlers(this.bot, this.db, config);\n    this.portfolioHandlers = new PortfolioHandlers(this.bot, this.db, config);\n    this.tradingHandlers = new TradingHandlers(this.bot, this.db, config, this.sellManager);\n    this.strategyHandlers = new StrategyHandlers(this.bot, this.db, config);\n    this.ruleHandlers = new RuleHandlers(this.bot, this.db, config);\n    this.exportHandlers = new ExportHandlers(this.bot, this.db, config);\n    this.securityHandlers = new SecurityHandlers(this, this.db, config);\n    this.copyTradeHandlers = new CopyTradeHandlers(this.bot, this.db, config);\n    this.settingsHandlers = new SettingsHandlers(this.bot, this.db, config, this, this.autonomousService);\n\n    // Define Solana config here (edit as needed)\n    const solanaConfig = {\n        rpcUrl: \"https://api.mainnet-beta.solana.com\",\n        feeLamports: 5000,\n        adminChatId: null,\n        heliusApiKey: null // or your real API key\n    };\n\n    // Pass the solanaConfig as the fourth argument\n    this.withdrawHandlers = new WithdrawHandlers(\n        this.bot,\n        this.db,\n        this.messageManager,\n        solanaConfig,\n        this\n    );\n\n    this.callbackRouter = new CallbackRouter(this.bot, {\n        walletHandlers: this.walletHandlers,\n        portfolioHandlers: this.portfolioHandlers,\n        tradingHandlers: this.tradingHandlers,\n        strategyHandlers: this.strategyHandlers,\n        ruleHandlers: this.ruleHandlers,\n        exportHandlers: this.exportHandlers,\n        securityHandlers: this.securityHandlers,\n        copyTradeHandlers: this.copyTradeHandlers,\n        settingsHandlers: this.settingsHandlers,\n        rulesCommand: this.rulesCommand,\n        bot: this \n    });\n}\n\n    async reconnectBot() {\n        console.log('Reconnection logic not applicable in webhook-only mode');\n    }\n\n    // Method to set bot instance from webhook server\n    setBot(bot) {\n        console.log('[TelegramBotManager] Setting bot instance and initializing handlers...');\n        this.bot = bot;\n        this.bot.userStates = new Map();\n        // Finish bot-dependent initialization now that bot exists\n        // Reuse existing config by reading from bot options if needed\n        this.initializeWithBot(this.config);\n        console.log('[TelegramBotManager] Handlers initialized successfully');\n        this.setupCommands();\n    }\n\n    // Get update type for logging\n    getUpdateType(update) {\n        if (update.message) return 'message';\n        if (update.callback_query) return 'callback_query';\n        if (update.inline_query) return 'inline_query';\n        if (update.chosen_inline_result) return 'chosen_inline_result';\n        if (update.channel_post) return 'channel_post';\n        if (update.edited_message) return 'edited_message';\n        if (update.edited_channel_post) return 'edited_channel_post';\n        if (update.shipping_query) return 'shipping_query';\n        if (update.pre_checkout_query) return 'pre_checkout_query';\n        if (update.poll) return 'poll';\n        if (update.poll_answer) return 'poll_answer';\n        if (update.my_chat_member) return 'my_chat_member';\n        if (update.chat_member) return 'chat_member';\n        if (update.chat_join_request) return 'chat_join_request';\n        return 'unknown';\n    }\n\n    // Handle webhook updates\n    async handleWebhookUpdate(update) {\n        try {\n            // Log the update structure for debugging\n            console.log('Processing webhook update:', {\n                updateId: update.update_id,\n                type: this.getUpdateType(update),\n                hasMessage: !!update.message,\n                hasCallbackQuery: !!update.callback_query,\n                callbackQueryStructure: update.callback_query ? {\n                    hasId: !!update.callback_query.id,\n                    hasFrom: !!update.callback_query.from,\n                    hasMessage: !!update.callback_query.message,\n                    hasData: !!update.callback_query.data,\n                    messageHasChat: !!(update.callback_query.message && update.callback_query.message.chat)\n                } : null,\n                fullUpdate: JSON.stringify(update, null, 2)\n            });\n            \n            // Handle different types of updates\n            if (update.message) {\n                await this.handleMessage(update.message);\n            } else if (update.callback_query) {\n                try {\n                    // Additional safety check for callback query structure\n                    if (!update.callback_query.message || !update.callback_query.message.chat || !update.callback_query.from) {\n                        console.error('Invalid callback query structure:', {\n                            hasMessage: !!update.callback_query.message,\n                            hasChat: !!(update.callback_query.message && update.callback_query.message.chat),\n                            hasFrom: !!update.callback_query.from,\n                            callbackQuery: update.callback_query\n                        });\n                        return;\n                    }\n                    \n                    // Additional check for required properties\n                    if (!update.callback_query.message.chat.id || !update.callback_query.from.id || !update.callback_query.data) {\n                        console.error('Missing required callback query properties:', {\n                            hasChatId: !!update.callback_query.message.chat.id,\n                            hasFromId: !!update.callback_query.from.id,\n                            hasData: !!update.callback_query.data,\n                            callbackQuery: update.callback_query\n                        });\n                        return;\n                    }\n                    \n                    // Create a context-like object for callback queries from webhook updates\n                    const ctx = {\n                        chat: update.callback_query.message.chat,\n                        from: update.callback_query.from,\n                        callbackQuery: update.callback_query\n                    };\n                    \n                    // Validate the context object before passing it\n                    if (!ctx.chat || !ctx.chat.id || !ctx.from || !ctx.from.id || !ctx.callbackQuery) {\n                        console.error('Invalid callback query context:', {\n                            hasChat: !!ctx.chat,\n                            hasChatId: !!(ctx.chat && ctx.chat.id),\n                            hasFrom: !!ctx.from,\n                            hasFromId: !!(ctx.from && ctx.from.id),\n                            hasCallbackQuery: !!ctx.callbackQuery,\n                            callbackQuery: update.callback_query\n                        });\n                        return;\n                    }\n                    \n                    // Additional logging for successful context creation\n                    console.log('Successfully created callback query context:', {\n                        chatId: ctx.chat.id,\n                        fromId: ctx.from.id,\n                        callbackData: ctx.callbackQuery.data\n                    });\n                    \n                    await this.handleCallbackQuery(ctx);\n                } catch (error) {\n                    console.error('Error processing callback query from webhook:', error);\n                    console.error('Callback query data:', update.callback_query);\n                }\n            } else if (update.inline_query) {\n                await this.handleInlineQuery(update.inline_query);\n            } else if (update.chosen_inline_result) {\n                await this.handleChosenInlineResult(update.chosen_inline_result);\n            }\n        } catch (error) {\n            console.error('Error handling webhook update:', error);\n            console.error('Update that caused error:', JSON.stringify(update, null, 2));\n        }\n    }\n\n    // Handle incoming messages\n    async handleMessage(msg) {\n        try {\n            // Validate message structure\n            if (!msg || !msg.chat || !msg.chat.id || !msg.from || !msg.from.id) {\n                console.error('Invalid message structure received:', {\n                    hasMsg: !!msg,\n                    hasChat: !!(msg && msg.chat),\n                    hasChatId: !!(msg && msg.chat && msg.chat.id),\n                    hasFrom: !!(msg && msg.from),\n                    hasFromId: !!(msg && msg.from && msg.from.id),\n                    message: msg\n                });\n                return;\n            }\n            \n            // Check for commands\n            if (msg.text && msg.text.startsWith('/')) {\n                await this.handleCommand(msg);\n            } else {\n                // Handle regular messages\n                await this.handleRegularMessage(msg);\n            }\n        } catch (error) {\n            console.error('Error handling message:', error);\n        }\n    }\n\n    // Handle commands\n    async handleCommand(msg) {\n        const chatId = msg.chat.id;\n        const telegramId = msg.from.id.toString();\n        const command = msg.text.split(' ')[0];\n\n        try {\n            switch (command) {\n                case '/start':\n                    await this.handleStartCommand(msg);\n                    break;\n                case '/help':\n                    await this.showHelp(chatId);\n                    break;\n                case '/wallet':\n                    await this.showWalletManagement(chatId, telegramId);\n                    break;\n                case '/strategy':\n                    await this.handleStrategies(chatId, telegramId);\n                    break;\n                case '/portfolio':\n                    if (this.portfolioHandlers && this.portfolioHandlers.handleViewPortfolio) {\n                        await this.portfolioHandlers.handleViewPortfolio(chatId, telegramId);\n                    } else {\n                        await this.bot.sendMessage(chatId, 'Portfolio feature is coming soon!');\n                    }\n                    break;\n                case '/claim':\n                    await this.handleClaimRewards(chatId, telegramId);\n                    break;\n                case '/status':\n                    await this.bot.sendMessage(chatId, '4T-Bot status: 🟢 Online and running!');\n                    break;\n                case '/buy':\n                    if (this.tradingHandlers && this.tradingHandlers.handleBuyCommand) {\n                        await this.tradingHandlers.handleBuyCommand(chatId, telegramId);\n                    } else {\n                        await this.bot.sendMessage(chatId, 'Buy command coming soon!');\n                    }\n                    break;\n                case '/sell':\n                    if (this.tradingHandlers && this.tradingHandlers.handleSellCommand) {\n                        await this.tradingHandlers.handleSellCommand(chatId, telegramId);\n                    } else {\n                        await this.bot.sendMessage(chatId, 'Sell command coming soon!');\n                    }\n                    break;\n                case '/set':\n                    await this.showSettings(chatId, telegramId);\n                    break;\n                default:\n                    await this.bot.sendMessage(chatId, 'Unknown command. Use /start to begin.');\n            }\n        } catch (error) {\n            console.error('Error handling command:', error);\n            await this.bot.sendMessage(chatId, 'Sorry, something went wrong. Please try again later.');\n        }\n    }\n\n    // Handle start command\n    async handleStartCommand(msg) {\n        const chatId = msg.chat.id;\n        const telegramId = msg.from.id.toString();\n        \n        try {\n            let user = await this.db.getUserByTelegramId(telegramId);\n            if (!user) {\n                user = await this.db.createUser(telegramId);\n            }\n\n            const wallets = await this.db.getWalletsByUserId(user.id);\n            const activeWallet = await this.db.getActiveWallet(user.id);\n            \n            if (!activeWallet) {\n                // New user - show wallet creation options\n                const welcomeMessage = `\n🎉 *Welcome to 4T-Bot!* 🚀\n\nI'm your automated trading assistant for Solana tokens. To get started, you'll need a Solana wallet.\n\n*Choose an option:*`;\n\n                const keyboard = {\n                    inline_keyboard: [\n                        [\n                            { text: '👛 Create New Wallet', callback_data: 'create_wallet' },\n                            { text: '📝 Import Wallet', callback_data: 'import_wallet' }\n                        ]\n                    ]\n                };\n\n                const sentMessage = await this.bot.sendMessage(chatId, welcomeMessage, {\n                    parse_mode: 'Markdown',\n                    reply_markup: keyboard\n                });\n\n                // Store welcome message ID for later deletion\n                this.messageManager.lastWelcomeMessageId = sentMessage.message_id;\n            } else {\n                if (this.menuManager) {\n                    await this.menuManager.showMainMenu(chatId, activeWallet, this.ruleEngine);\n                } else {\n                    console.error('MenuManager not initialized');\n                    await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n                }\n            }\n        } catch (error) {\n            console.error('Error in /start command:', error);\n            if (this.bot) {\n                await this.bot.sendMessage(chatId, 'Sorry, something went wrong. Please try again later.');\n            } else {\n                console.error('Bot instance not available for error message');\n            }\n        }\n    }\n\n   // Handle regular messages\nasync handleRegularMessage(msg) {\n    try {\n        // Additional validation for message structure\n        if (!msg || !msg.chat || !msg.chat.id || !msg.from || !msg.from.id) {\n            console.error('Invalid message structure in handleRegularMessage:', {\n                hasMsg: !!msg,\n                hasChat: !!(msg && msg.chat),\n                hasChatId: !!(msg && msg.chat && msg.chat.id),\n                hasFrom: !!(msg && msg.from),\n                hasFromId: !!(msg && msg.from && msg.from.id),\n                message: msg\n            });\n            return;\n        }\n\n        const chatId = msg.chat.id;\n        const telegramId = msg.from.id.toString();\n        const messageText = msg.text || '';\n\n        // Get user state BEFORE you use it!\n        const userState = this.bot.userStates.get(telegramId);\n\n        // Withdrawal flow: let withdrawHandlers manage withdrawal states\n        if (userState && this.withdrawHandlers && typeof this.withdrawHandlers.handleMessage === 'function') {\n            const ctx = { chat: msg.chat, from: msg.from, message: msg };\n            const handled = await this.withdrawHandlers.handleMessage(ctx);\n            if (handled) return;\n        }\n\n        console.log('Regular message received:', messageText);\n\n        // Create context object for handlers\n        const ctx = {\n            chat: msg.chat,\n            from: msg.from,\n            message: msg\n        };\n\n        // Try to handle message through various handlers\n        let handled = false;\n\n        // Try wallet handlers first (for wallet addresses, private keys, etc.)\n        if (this.walletHandlers && this.walletHandlers.handleMessage) {\n            try {\n                const walletResult = await this.walletHandlers.handleMessage(ctx, userState);\n                if (walletResult && (walletResult.handled || walletResult === true)) {\n                    handled = true;\n                    console.log('Message handled by wallet handlers');\n\n                    // Clear user state if requested\n                    if (walletResult.clearState && userState) {\n                        this.bot.userStates.delete(telegramId);\n                        console.log('User state cleared');\n                    }\n                }\n            } catch (error) {\n                console.error('Error in wallet handlers:', error);\n            }\n}\n            // Try settings handlers\n            if (!handled && this.settingsHandlers && this.settingsHandlers.handleMessage) {\n                try {\n                    const settingsResult = await this.settingsHandlers.handleMessage(ctx, userState);\n                    if (settingsResult && (settingsResult.handled || settingsResult === true)) {\n                        handled = true;\n                        console.log('Message handled by settings handlers');\n                    }\n                } catch (error) {\n                    console.error('Error in settings handlers:', error);\n                }\n            }\n            \n            // Try trading handlers\n            if (!handled && this.tradingHandlers && this.tradingHandlers.handleMessage) {\n                try {\n                    const tradingResult = await this.tradingHandlers.handleMessage(ctx, userState);\n                    if (tradingResult && (tradingResult.handled || tradingResult === true)) {\n                        handled = true;\n                        console.log('Message handled by trading handlers');\n                    }\n                } catch (error) {\n                    console.error('Error in trading handlers:', error);\n                }\n            }\n            \n            // Try strategy handlers\n            if (!handled && this.strategyHandlers && this.strategyHandlers.handleMessage) {\n                try {\n                    const strategyResult = await this.strategyHandlers.handleMessage(ctx, userState);\n                    if (strategyResult && (strategyResult.handled || strategyResult === true)) {\n                        handled = true;\n                        console.log('Message handled by strategy handlers');\n                    }\n                } catch (error) {\n                    console.error('Error in strategy handlers:', error);\n                }\n            }\n            \n            // Try RulesCommand for autonomous strategy creation and rule creation\n            if (!handled && this.rulesCommand && this.rulesCommand.userStates && this.rulesCommand.userStates.has(telegramId)) {\n                try {\n                    console.log('User has RulesCommand state, routing to RulesCommand handler');\n                    await this.rulesCommand.handleMessage(ctx);\n                    handled = true;\n                    console.log('Message handled by RulesCommand');\n                } catch (error) {\n                    console.error('Error in RulesCommand handler:', error);\n                }\n            }\n            \n            // Try rule handlers for rule creation and management\n            if (!handled && this.ruleHandlers && this.ruleHandlers.handleTextInput) {\n                try {\n                    const ruleResult = await this.ruleHandlers.handleTextInput(chatId, telegramId, messageText);\n                    if (ruleResult) {\n                        handled = true;\n                        console.log('Message handled by rule handlers');\n                    }\n                } catch (error) {\n                    console.error('Error in rule handlers:', error);\n                }\n            }\n            \n            // If no handler processed the message, check if it looks like a token address\n            if (!handled && messageText && messageText.length > 30 && messageText.length < 50) {\n                // This might be a Solana token address\n                console.log('Potential token address detected, checking with trading handlers...');\n                \n                // Try to handle as a token address\n                if (this.tradingHandlers && this.tradingHandlers.handleTokenAddress) {\n                    try {\n                        await this.tradingHandlers.handleTokenAddress(chatId, telegramId, messageText);\n                        handled = true;\n                        console.log('Token address handled by trading handlers');\n                    } catch (error) {\n                        console.error('Error handling token address:', error);\n                    }\n                }\n            }\n            \n            // If still not handled, provide helpful response\n            if (!handled) {\n                const helpMessage = `\n🤖 *Message Received*\n\nI received your message: \\`${messageText}\\`\n\n*What you can do:*\n• Send a Solana token address to analyze it\n• Use /start to see the main menu\n• Use /help for available commands\n\n*Need help?* Use /start to begin!`;\n\n                await this.bot.sendMessage(chatId, helpMessage, {\n                    parse_mode: 'Markdown'\n                });\n            }\n            \n        } catch (error) {\n            console.error('Error handling regular message:', error);\n            try {\n                await this.bot.sendMessage(msg.chat.id, 'Sorry, something went wrong while processing your message. Please try again.');\n            } catch (sendError) {\n                console.error('Error sending error message:', sendError);\n            }\n        }\n    }\n\n  \n    // Handle inline queries\n    async handleInlineQuery(inlineQuery) {\n        // Implement inline query handling if needed\n        console.log('Inline query received:', inlineQuery.query);\n    }\n\n    // Handle chosen inline results\n    async handleChosenInlineResult(chosenInlineResult) {\n        // Implement chosen inline result handling if needed\n        console.log('Chosen inline result:', chosenInlineResult);\n    }\n\n    setupCommands() {\n        // Only set up event listeners if we have a bot instance and we're in polling mode\n        if (!this.bot || this.webhookMode) {\n            return;\n        }\n\n        // Start command\n        this.bot.onText(/\\/start/, async (msg) => {\n            const chatId = msg.chat.id;\n            const telegramId = msg.from.id.toString();\n            \n            try {\n                let user = await this.db.getUserByTelegramId(telegramId);\n                if (!user) {\n                    user = await this.db.createUser(telegramId);\n                }\n\n                const wallets = await this.db.getWalletsByUserId(user.id);\n                const activeWallet = await this.db.getActiveWallet(user.id);\n                \n                if (!activeWallet) {\n                    // New user - show wallet creation options\n                    const welcomeMessage = `\n🎉 *Welcome to 4T-Bot!* 🚀\n\nI'm your automated trading assistant for Solana tokens. To get started, you'll need a Solana wallet.\n\n*Choose an option:*`;\n\n                    const keyboard = {\n                        inline_keyboard: [\n                            [\n                                { text: '👛 Create New Wallet', callback_data: 'create_wallet' },\n                                { text: '📝 Import Wallet', callback_data: 'import_wallet' }\n                            ]\n                        ]\n                    };\n\n                    const sentMessage = await this.bot.sendMessage(chatId, welcomeMessage, {\n                        parse_mode: 'Markdown',\n                        reply_markup: keyboard\n                    });\n\n                    // Store welcome message ID for later deletion\n                    this.messageManager.lastWelcomeMessageId = sentMessage.message_id;\n                } else {\n                    if (this.menuManager) {\n                        await this.menuManager.showMainMenu(chatId, activeWallet, this.ruleEngine);\n                    } else {\n                        console.error('MenuManager not initialized');\n                        await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n                    }\n                }\n            } catch (error) {\n                console.error('Error in /start command:', error);\n                if (this.bot) {\n                    await this.bot.sendMessage(chatId, 'Sorry, something went wrong. Please try again later.');\n                } else {\n                    console.error('Bot instance not available for error message');\n                }\n            }\n        });\n\n        // Handle callback queries (inline button clicks)\n        this.bot.on('callback_query', async (callbackQuery) => {\n            try {\n                // Create a context object that includes both the callback query and its message\n                const ctx = {\n                    callbackQuery,\n                    from: callbackQuery.from,\n                    chat: callbackQuery.message.chat,\n                    message: callbackQuery.message\n                };\n\n                // Handle all callbacks through the main handler\n                await this.handleCallbackQuery(ctx);\n            } catch (error) {\n                console.error('Error handling callback query:', error);\n                const chatId = callbackQuery.message.chat.id;\n                await this.messageManager.sendAndStoreMessage(chatId, 'Sorry, there was an error processing your request. Please try again.');\n            }\n        });\n\n        // Handle messages\n        this.bot.on('message', async (msg) => {\n            const chatId = msg.chat.id;\n            const telegramId = msg.from.id.toString();\n            const text = msg.text;\n\n            try {\n                console.log('[MessageHandler] Triggered for', telegramId, text);\n                // 1. Skip if the message is a command\n                if (text && text.startsWith('/')) {\n                    return;\n                }\n\n                // 2. ABSOLUTE TOP: SELL MANAGER CUSTOM SELL INPUT\n                if (this.sellManager.hasPendingSell(telegramId)) {\n                    const pendingSell = this.sellManager.pendingSell.get(telegramId);\n                    console.log('[MessageHandler] Pending sell for', telegramId, pendingSell);\n                    if (pendingSell && pendingSell.status === 'waiting_for_custom_amount') {\n                        console.log('[MessageHandler] Routing to handleCustomSellAmountInput for', telegramId, text, pendingSell);\n                        await this.tradingHandlers.handleCustomSellAmountInput(chatId, telegramId, text);\n                        return;\n                    }\n                }\n\n                // 3. All other handlers come AFTER\n                if (this.rulesCommand.userStates.has(telegramId)) {\n                    console.log('[RulesCommand] Handling message for', telegramId);\n                    await this.rulesCommand.handleMessage({\n                        chat: { id: chatId },\n                        from: { id: telegramId },\n                        message: { text }\n                    });\n                    return;\n                }\n\n                if (this.ruleHandlers.userStates.has(telegramId)) {\n                    console.log('[RuleHandlers] Handling message for', telegramId);\n                    const handled = await this.ruleHandlers.handleTextInput(chatId, telegramId, text);\n                    if (handled) {\n                        return;\n                    }\n                }\n\n                // Debug logging for user state routing\n                console.log('[MessageHandler] Debug - User states check:', {\n                    telegramId,\n                    hasRulesCommandState: this.rulesCommand.userStates.has(telegramId),\n                    hasRuleHandlersState: this.ruleHandlers.userStates.has(telegramId),\n                    rulesCommandStates: Array.from(this.rulesCommand.userStates.keys()),\n                    ruleHandlersStates: Array.from(this.ruleHandlers.userStates.keys())\n                });\n\n                const userState = this.bot.userStates.get(telegramId);\n                if (userState) {\n                    console.log('[UserState] Found user state in message handler:', userState);\n                    \n                    // Try to delegate to appropriate handlers first\n                    const ctx = {\n                        chat: { id: chatId },\n                        from: { id: telegramId },\n                        message: { text }\n                    };\n                    \n                    // Try wallet handlers first for wallet-related states\n                    if (userState.state === 'awaiting_private_key' || userState.state === 'waiting_external_wallet') {\n                        console.log('🔍 Trying wallet handlers for state:', userState.state);\n                        const walletResult = await this.walletHandlers.handleMessage(ctx, userState);\n                        if (walletResult && walletResult.handled) {\n                            console.log('✅ Wallet handler processed the message');\n                            if (walletResult.clearState) {\n                                this.bot.userStates.delete(telegramId);\n                            }\n                            return;\n                        }\n                    }\n                    \n                    // Try settings handlers for settings-related states\n                    if (userState.state && userState.state.startsWith('waiting_')) {\n                        console.log('🔍 Trying settings handlers for state:', userState.state);\n                        const settingsResult = await this.settingsHandlers.handleMessage(ctx, userState);\n                        if (settingsResult && settingsResult.handled) {\n                            console.log('✅ Settings handler processed the message');\n                            if (settingsResult.clearState) {\n                                this.bot.userStates.delete(telegramId);\n                            }\n                            if (settingsResult.redirectTo) {\n                                switch (settingsResult.redirectTo) {\n                                    case 'trade_settings':\n                                        await this.settingsHandlers.handleTradeSettings(chatId, telegramId);\n                                        break;\n                                    case 'risk_settings':\n                                        await this.settingsHandlers.handleRiskSettings(chatId, telegramId);\n                                        break;\n                                }\n                            }\n                            return;\n                        }\n                    }\n                    \n                    // Handle specific states that need special processing\n                    switch (userState.state) {\n                        case 'waiting_external_wallet':\n                            await this.handleExternalWalletInput(chatId, telegramId, text);\n                            return;\n                        case 'awaiting_private_key':\n                            // This is now handled by wallet handlers above\n                            return;\n                        case 'awaiting_passphrase':\n                        case 'awaiting_new_passphrase':\n                            if (text && text.trim().length > 0) {\n                                try {\n                                    await this.securityHandlers.handlePassphraseInput(chatId, telegramId, text);\n                                } catch (error) {\n                                    await this.messageManager.sendAndStoreMessage(chatId, `Sorry, ${error.message}. Please try again.`);\n                                }\n                            } else {\n                                await this.messageManager.sendAndStoreMessage(chatId, 'Please send a valid passphrase.');\n                            }\n                            return;\n                        case 'awaiting_custom_buy_amount':\n                            // Delegate to tradingHandlers for custom buy amount input\n                            const ctx = {\n                                chat: { id: chatId },\n                                from: { id: telegramId },\n                                message: { text }\n                            };\n                            await this.tradingHandlers.handleMessage(ctx, userState);\n                            // Optionally clear state if needed (handled by tradingHandlers)\n                            return;\n                    }\n                }\n\n                // Check if user has pending sell with custom amount\n                if (this.sellManager.hasPendingSell(telegramId)) {\n                    const pendingSell = this.sellManager.pendingSell.get(telegramId);\n                    if (pendingSell && pendingSell.status === 'waiting_for_custom_amount') {\n                        await this.tradingHandlers.handleCustomSellAmountInput(chatId, telegramId, text);\n                        return;\n                    }\n                }\n\n                // Handle other message types\n                if (text && text.length > 0) {\n                    const cleanText = text.trim();\n                    \n                    // Check if the message is a token address (Solana address format)\n                    if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(cleanText)) {\n                        await this.tradingHandlers.handleTokenCheck(chatId, telegramId, cleanText);\n                    }\n                }\n            } catch (error) {\n                console.error('Error handling message:', error);\n                await this.messageManager.sendAndStoreMessage(chatId, 'Sorry, something went wrong. Please try again.');\n            }\n        });\n    }\n\n    // Message management delegated to MessageManager\n    async sendAndStoreMessage(chatId, message, options = {}) {\n        return await this.messageManager.sendAndStoreMessage(chatId, message, options, this.reconnectBot.bind(this));\n    }\n\n    // Menu management delegated to MenuManager\n    async showMainMenu(chatId, activeWallet, ruleEngine = null, telegramId = null) {\n        if (!this.menuManager) {\n            console.error('MenuManager not initialized');\n            await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n            return;\n        }\n        return await this.menuManager.showMainMenu(chatId, activeWallet, ruleEngine || this.ruleEngine, telegramId);\n    }\n\n    async showSettings(chatId, telegramId) {\n        if (!this.menuManager) {\n            console.error('MenuManager not initialized');\n            await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n            return;\n        }\n        return await this.menuManager.showSettings(chatId, telegramId);\n    }\n\n    async showWalletManagement(chatId, telegramId) {\n        if (!this.menuManager) {\n            console.error('MenuManager not initialized');\n            await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n            return;\n        }\n        return await this.menuManager.showWalletManagement(chatId, telegramId);\n    }\n\n    async handleHelp(chatId) {\n        if (!this.menuManager) {\n            console.error('MenuManager not initialized');\n            await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n            return;\n        }\n        return await this.menuManager.showHelp(chatId);\n    }\n\n    // Wallet creation and configuration methods handled by respective handlers\n    async handleConfigureStrategy(chatId, telegramId) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            const strategy = await this.db.getActiveStrategy(user.id);\n\n            const message = strategy ? `\n*Current Strategy:*\n\\`\\`\\`json\n${JSON.stringify(strategy.strategy_json, null, 2)}\n\\`\\`\\`\n\n*Available Strategies:*` : `\n*No Active Strategy*\n\n*Available Strategies:*`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: '📈 Volume Spike', callback_data: 'strategy_volume_spike' },\n                        { text: '📉 Dip Buy', callback_data: 'strategy_dip_buy' }\n                    ],\n                    [\n                        { text: '🎮 Narrative', callback_data: 'strategy_narrative' },\n                        { text: '📊 Momentum', callback_data: 'strategy_momentum' }\n                    ],\n                    [\n                        { text: '📈 Volatility', callback_data: 'strategy_volatility' },\n                        { text: '👥 Copy Trade', callback_data: 'strategy_copy_trade' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error configuring strategy:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while configuring your strategy.');\n        }\n    }\n\n    async handleClaimRewards(chatId, telegramId) {\n        const message = `\n*💎 Claim Status*\n\n*Available Rewards:* 0 4TOOL\n*Last Claim:* Never\n*Next Claim:* Available now`;\n\n        const keyboard = {\n            inline_keyboard: [\n                [\n                    { text: '💎 Claim Rewards', callback_data: 'confirm_claim' }\n                ]\n            ]\n        };\n\n        await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n    }\n\n    async handleMarketOverview(chatId) {\n        const message = `\n*📈 Market Overview*\n\n*Top Gainers:*\nNo data available\n\n*Top Losers:*\nNo data available\n\n*Trending Tokens:*\nNo data available`;\n\n        const keyboard = {\n            inline_keyboard: [\n                [\n                    { text: '🔄 Refresh', callback_data: 'refresh_market' }\n                ]\n            ]\n        };\n\n        await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n    }\n\n    // Helper methods delegated to TelegramUtils\n    async generateWallet() {\n        return TelegramUtils.generateWallet();\n    }\n\n    encryptPrivateKey(privateKey, password) {\n        return TelegramUtils.encryptPrivateKey(privateKey, password);\n    }\n\n    decryptPrivateKey(encryptedData, password) {\n        return TelegramUtils.decryptPrivateKey(encryptedData, password);\n    }\n\n    validateWalletAddress(address) {\n        return TelegramUtils.validateWalletAddress(address);\n    }\n\n    // Trade methods handled by tradingHandlers\n\n    async handleStrategies(chatId, telegramId) {\n        return await this.rulesManager.handleStrategies(chatId, telegramId);\n    }\n\n    // Helper methods for strategy management\n    getStrategyIcon(type) {\n        return TelegramUtils.getStrategyIcon(type);\n    }\n\n    formatStrategyName(type) {\n        return TelegramUtils.formatStrategyName(type);\n    }\n\n    // Callback handler methods for rule and strategy management\n    async handleToggleAllRules(chatId, telegramId) {\n        return await this.rulesManager.handleToggleAllRules(chatId, telegramId);\n    }\n\n    async handleDeleteRulesMenu(chatId, telegramId) {\n        return await this.rulesManager.handleDeleteRulesMenu(chatId, telegramId);\n    }\n\n    async handleDeleteRule(chatId, telegramId, ruleId) {\n        return await this.rulesManager.handleDeleteRule(chatId, telegramId, ruleId);\n    }\n\n    async handleConfirmDeleteRule(chatId, telegramId, ruleId) {\n        return await this.rulesManager.handleConfirmDeleteRule(chatId, telegramId, ruleId);\n    }\n\n    async handleStrategyPerformance(chatId, telegramId) {\n        return await this.rulesManager.handleStrategyPerformance(chatId, telegramId);\n    }\n    \n    // Security methods handled by securityHandlers\n\n    async handleTokenReport(chatId, telegramId) {\n        const message = `\n*📊 Token Report*\n\nPlease enter the token address you want to check:`;\n\n        await this.sendAndStoreMessage(chatId, message, {\n            parse_mode: 'Markdown'\n        });\n\n        // Store the state to handle the next message as a token address\n        this.pendingTokenCheck = {\n            type: 'report',\n            telegramId\n        };\n    }\n\n    // Copy trade methods handled by copyTradeHandlers\n    async handleAddExternalWallet(chatId, telegramId) {\n        try {\n            const message = `\n*➕ Add External Wallet*\n\nPlease enter the wallet address you want to monitor for copy trading.\n\nFormat: Base58 encoded Solana address`;\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown'\n            });\n\n            // Set user state to wait for wallet address\n            this.bot.userStates.set(telegramId, {\n                state: 'waiting_external_wallet',\n                data: {}\n            });\n\n        } catch (error) {\n            console.error('Error handling add external wallet:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, there was an error adding the external wallet.');\n        }\n    }\n\n    async handleExternalWalletInput(chatId, telegramId, walletAddress) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            \n            try {\n                // Skip validation and directly add the wallet address\n                await this.db.addExternalWallet(user.id, walletAddress);\n                \n                const message = `\n*✅ External Wallet Added*\n\nWallet address: \\`${walletAddress}\\`\n\nThe wallet has been added to your monitored list. You can now enable copy trading for this wallet.`;\n\n                const keyboard = {\n                    inline_keyboard: [\n                        [\n                            { text: '🔄 Back to Copy Trade', callback_data: 'strategy_copy_trade' }\n                        ]\n                    ]\n                };\n\n                await this.sendAndStoreMessage(chatId, message, {\n                    parse_mode: 'Markdown',\n                    reply_markup: keyboard\n                });\n\n            } catch (error) {\n                if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {\n                    await this.sendAndStoreMessage(chatId, 'This wallet address is already being monitored.');\n                } else {\n                    throw error;\n                }\n            }\n\n            // Clear user state\n            this.bot.userStates.delete(telegramId);\n\n        } catch (error) {\n            console.error('Error handling external wallet input:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, there was an error adding the external wallet.');\n        }\n    }\n\n    // Buy/Sell methods handled by tradingHandlers and respective managers\n    async handleConfirmBuy(chatId, telegramId, params) {\n        return await this.tradingHandlers.handleConfirmBuy(chatId, telegramId, params);\n    }\n\n    async handleExecuteBuy(chatId, telegramId, params) {\n        return await this.tradingHandlers.handleExecuteBuy(chatId, telegramId, params);\n    }\n\n    async showTradeMenu(chatId) {\n        if (!this.menuManager) {\n            console.error('MenuManager not initialized');\n            await this.bot.sendMessage(chatId, 'Sorry, the menu system is not available. Please try again later.');\n            return;\n        }\n        return await this.menuManager.showTradeMenu(chatId);\n    }\n\n    // Helper methods delegated to utils and handlers\n    async createRuleAndShowSuccess(chatId, telegramId) {\n        try {\n            const ctx = {\n                chat: { id: chatId },\n                from: { id: telegramId }\n            };\n            \n            await this.rulesCommand.createRuleAndShowSuccess(ctx);\n        } catch (error) {\n            console.error('Error creating rule:', error);\n            await this.bot.sendMessage(chatId, 'Sorry, there was an error creating your rule. Please try again.');\n        }\n    }\n\n    async getCurrentSelections(data) {\n        if (!data) {\n            return '*Current Selections:*\\nNo criteria selected yet\\n';\n        }\n\n        let selections = '*Current Selections:*\\n';\n        \n        if (data.marketCap && data.marketCap.value) {\n            const range = data.marketCap.value;\n            if (range && typeof range.min !== 'undefined' && typeof range.max !== 'undefined') {\n                selections += `- Market Cap: $${range.min.toLocaleString()} - $${range.max === Infinity ? '∞' : range.max.toLocaleString()}\\n`;\n            }\n        }\n        \n        if (data.price && data.price.value) {\n            const range = data.price.value;\n            if (range && typeof range.min !== 'undefined' && typeof range.max !== 'undefined') {\n                selections += `- Price: $${range.min.toFixed(4)} - $${range.max === Infinity ? '∞' : range.max.toFixed(4)}\\n`;\n            }\n        }\n        \n        if (data.volume && data.volume.value) {\n            const range = data.volume.value;\n            if (range && typeof range.min !== 'undefined' && typeof range.max !== 'undefined') {\n                selections += `- Volume: $${range.min.toLocaleString()} - $${range.max === Infinity ? '∞' : range.max.toLocaleString()}\\n`;\n            }\n        }\n        \n        if (data.liquidity && data.liquidity.value) {\n            const range = data.liquidity.value;\n            if (range && typeof range.min !== 'undefined' && typeof range.max !== 'undefined') {\n                selections += `- Liquidity: $${range.min.toLocaleString()} - $${range.max === Infinity ? '∞' : range.max.toLocaleString()}\\n`;\n            }\n        }\n        \n        if (data.category) {\n            selections += `- Category: ${data.category.charAt(0).toUpperCase() + data.category.slice(1)}\\n`;\n        }\n        \n        if (data.timeframe) {\n            selections += `- Timeframe: ${data.timeframe}\\n`;\n        }\n\n        if (selections === '*Current Selections:*\\n') {\n            selections += 'No criteria selected yet\\n';\n        }\n\n        return selections;\n    }\n\n    async showFilterOptions(chatId, telegramId) {\n        const userState = this.bot.userStates.get(telegramId);\n        if (!userState) {\n            await this.bot.sendMessage(chatId, 'Please start over with /rules command.');\n            return;\n        }\n        \n        const selections = this.getCurrentSelections(userState.data);\n        \n        const message = `\n*🔍 Filter Options*\n\n${selections}\n\nSelect the criteria for your filter rule:`;\n\n        const keyboard = {\n            inline_keyboard: [\n                [\n                    { text: '📊 Market Cap', callback_data: 'mcap_select' },\n                    { text: '💰 Price Range', callback_data: 'price_select' }\n                ],\n                [\n                    { text: '💧 Liquidity', callback_data: 'liquidity_select' },\n                    { text: '📈 Volume', callback_data: 'volume_select' }\n                ],\n                [\n                    { text: '🏷️ Category', callback_data: 'category_select' },\n                    { text: '⏰ Timeframe', callback_data: 'timeframe_select' }\n                ],\n                [\n                    { text: '✅ Done', callback_data: 'confirm_rule' }\n                ],\n                [\n                    { text: '◀️ Back', callback_data: 'rules_create' }\n                ]\n            ]\n        };\n\n        await this.bot.sendMessage(chatId, message, {\n            parse_mode: 'Markdown',\n            reply_markup: keyboard\n        });\n    }\n\n\n\n    // All callback handling delegated to CallbackRouter, but with custom actions first\n    // --- Handle Rewards button ---\n async handleCallbackQuery(ctx) {\n        const chatId = ctx.chat.id;\n        const telegramId = ctx.from.id.toString();\n        const callbackData = ctx.callbackQuery.data;\n\n        try {\n            // Fetch user and wallet data first, as it's required for menu navigation\n            const user = await this.db.getUserByTelegramId(telegramId);\n            const activeWallet = user ? await this.db.getActiveWallet(user.id) : null;\n            \n            // --- Handle Universal Navigation (Main Menu, Wallet Management) ---\n            if (callbackData === 'main_menu' || callbackData === 'wallet_management') {\n                if (callbackData === 'wallet_management') {\n                    // Navigate to wallet management screen\n                    await this.showWalletManagement(chatId, telegramId);\n                } else if (activeWallet && this.menuManager) {\n                    // Navigate to Main Menu (requires activeWallet)\n                    await this.menuManager.showMainMenu(chatId, activeWallet, this.ruleEngine, telegramId);\n                } else {\n                    // If no wallet, redirect to start/onboarding\n                    await this.handleStartCommand(ctx.message || { chat: { id: chatId }, from: { id: telegramId } });\n                }\n                \n                // Acknowledge the callback query to dismiss the loading clock\n                if (this.bot && this.bot.answerCallbackQuery) {\n                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n                }\n                return; \n            }\n\n            // --- Handle Custom Actions (Rewards, Withdraw, Token Selection) ---\n\n            if (callbackData === 'rewards') {\n                await this.handleClaimRewards(chatId, telegramId);\n            }\n\n           // In TelegramBotManager.js, inside the handleCallbackQuery(ctx) function\n\n            // ... (Handling universal navigation: 'main_menu', 'wallet_management')\n\n            // --- Handle Withdraw button ---\n            if (callbackData === 'withdraw') {\n                await this.withdrawHandlers.handleWithdrawStart(chatId, telegramId);\n                \n                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n                if (this.bot && this.bot.answerCallbackQuery) {\n                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n                }\n                return; \n            }\n\n            // --- Handle token selection for withdrawal ---\n            if (callbackData.startsWith('withdraw_token_')) {\n                await this.withdrawHandlers.handleCallbackQuery(ctx);\n                \n                // CRITICAL FIX: Acknowledge the callback and RETURN to stop further routing\n                if (this.bot && this.bot.answerCallbackQuery) {\n                    await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n                }\n                return; \n            }\n            \n            // ... (rest of the logic, like 'rewards', 'settings', etc., should also return after acknowledging)\n            \n            // --- DELEGATE TO ROUTER FOR EVERYTHING ELSE (Trading, Strategy, Security) ---\n            await this.callbackRouter.handleCallbackQuery(ctx);\n            \n            // Acknowledge callback for all actions handled successfully above\n            if (this.bot && this.bot.answerCallbackQuery) {\n                await this.bot.answerCallbackQuery(ctx.callbackQuery.id);\n            }\n\n        } catch (error) {\n            console.error('Error handling callback query:', error);\n            // Ensure callback is answered on failure to clear the user's loading clock\n            if (this.bot && this.bot.answerCallbackQuery) {\n                await this.bot.answerCallbackQuery(ctx.callbackQuery.id, 'Sorry, an error occurred processing your request.');\n            }\n        }\n    }\n\n\n    async showStrategyMenu(chatId, telegramId) {\n        try {\n            const message = `\n*🎯 Trading Strategies*\n\nSelect a strategy type:\n\n- 📈 Volume Spike - Trade on significant volume increases\n- 📉 Dip Buy - Buy during price dips\n- 📊 Momentum - Trade based on price momentum\n- 📈 Volatility - Trade based on price volatility\n- 👥 Copy Trading - Mirror successful traders\n- ⚖️ Portfolio Rebalancing - Maintain target allocations\n- 🎯 Event Triggers - React to token events\n- 🛡️ Risk Management - Protect your portfolio`;\n\n            const keyboard = {\n                inline_keyboard: [\n                    [\n                        { text: '📈 Volume Spike', callback_data: 'volume_spike' },\n                        { text: '📉 Dip Buy', callback_data: 'dip_buy' }\n                    ],\n                    [\n                        { text: '📊 Momentum', callback_data: 'momentum' }\n                    ],\n                    [\n                        { text: '📈 Volatility', callback_data: 'volatility' },\n                        { text: '👥 Copy Trading', callback_data: 'copy_trade' }\n                    ],\n                    [\n                        { text: '⚖️ Portfolio Rebalance', callback_data: 'portfolio_rebalance' },\n                        { text: '🎯 Event Triggers', callback_data: 'event_triggers' }\n                    ],\n                    [\n                        { text: '🛡️ Risk Management', callback_data: 'risk_management' }\n                    ],\n                    [\n                        { text: '◀️ Back', callback_data: 'trade' }\n                    ]\n                ]\n            };\n\n            await this.sendAndStoreMessage(chatId, message, {\n                parse_mode: 'Markdown',\n                reply_markup: keyboard\n            });\n        } catch (error) {\n            console.error('Error in showStrategyMenu:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, something went wrong while loading the strategy menu.');\n        }\n    }\n    isStrategyActive(strategies, strategyType) {\n        return strategies.some(strategy => {\n            try {\n                const data = JSON.parse(strategy.strategy_json);\n                return data.type === strategyType && data.params && data.params.isActive === true;\n            } catch (e) {\n                return false;\n            }\n        });\n    }\n\n    async handleStrategyToggle(chatId, telegramId, strategyType) {\n        try {\n            const user = await this.db.getUserByTelegramId(telegramId);\n            if (!user) {\n                await this.sendAndStoreMessage(chatId, 'Please create an account first.');\n                return;\n            }\n\n            const strategies = await this.db.getUserStrategies(user.id);\n            const isCurrentlyActive = this.isStrategyActive(strategies, strategyType);\n\n            if (isCurrentlyActive) {\n                // Deactivate the strategy\n                const currentStrategy = strategies.find(s => {\n                    try {\n                        const data = JSON.parse(s.strategy_json);\n                        return data.type === strategyType && data.params && data.params.isActive === true;\n                    } catch (e) {\n                        return false;\n                    }\n                });\n\n                if (currentStrategy) {\n                    const data = JSON.parse(currentStrategy.strategy_json);\n                    data.params.isActive = false;\n                    await this.db.updateStrategy(currentStrategy.id, {\n                        strategy_json: JSON.stringify(data)\n                    });\n                }\n\n                await this.sendAndStoreMessage(chatId, `❌ ${this.formatStrategyName(strategyType)} strategy has been deactivated.`);\n            } else {\n                // First, deactivate all other strategies (mutual exclusion)\n                for (const strategy of strategies) {\n                    try {\n                        const data = JSON.parse(strategy.strategy_json);\n                        if (data.params && data.params.isActive === true) {\n                            data.params.isActive = false;\n                            await this.db.updateStrategy(strategy.id, {\n                                strategy_json: JSON.stringify(data)\n                            });\n                        }\n                    } catch (e) {\n                        console.error('Error deactivating strategy:', strategy.id, e);\n                    }\n                }\n\n                // Create or activate the selected strategy\n                let targetStrategy = strategies.find(s => {\n                    try {\n                        const data = JSON.parse(s.strategy_json);\n                        return data.type === strategyType;\n                    } catch (e) {\n                        return false;\n                    }\n                });\n\n                if (targetStrategy) {\n                    // Update existing strategy\n                    const data = JSON.parse(targetStrategy.strategy_json);\n                    data.params.isActive = true;\n                    await this.db.updateStrategy(targetStrategy.id, {\n                        strategy_json: JSON.stringify(data)\n                    });\n                } else {\n                    // Create new strategy with default parameters\n                    const defaultParams = TelegramUtils.getDefaultStrategyParams(strategyType);\n                    defaultParams.isActive = true;\n                    await this.db.createStrategy(user.id, {\n                        type: strategyType,\n                        params: defaultParams\n                    });\n                }\n\n                await this.sendAndStoreMessage(chatId, `✅ ${TelegramUtils.formatStrategyName(strategyType)} strategy has been activated!`);\n            }\n\n            // Return to strategies menu\n            await this.handleStrategies(chatId, telegramId);\n        } catch (error) {\n            console.error('Error in handleStrategyToggle:', error);\n            await this.sendAndStoreMessage(chatId, 'Sorry, there was an error toggling the strategy.');\n        }\n    }\n\n    // Helper method for checking if strategy is active\n    isStrategyActive(strategies, strategyType) {\n        return TelegramUtils.isStrategyActive(strategies, strategyType);\n    }\n}\n\nmodule.exports = TelegramBotManager;"
        }
    ]
}